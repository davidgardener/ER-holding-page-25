<!DOCTYPE html>
<html>
<head>
  <title>Coming Soon</title>
  <link rel="icon" type="image/png" href="../ERfavicon.png">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
      background: #f9f9f9;
      overflow: hidden;
    }

    #glsl-bg {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      display: block;
      pointer-events: none; /* allows clicks through the canvas */
    }

    .container {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      text-align: center;
    }

    img {
      width: 50vw;
      max-width: 300px;
      height: auto;
      margin-bottom: 20px;
    }

    h1 {
      margin: 0 0 10px;
    }

    p {
      margin: 0;
    }
  </style>
</head>
<body>
  <canvas id="glsl-bg"></canvas>
  <div class="container">
    <img src="../logo.png" alt="Site Logo">
    <h1>EXPANDED REALITIES</h1>
    <h2>Website is Coming Soon</h2>
    <p>Stay tuned!</p>
  </div>
  <script id="fragShader" type="x-shader/x-fragment">



    precision highp float;
uniform float u_time;
uniform vec2 u_resolution;

// 3D Simplex noise (GLSL, Ashima Arts, public domain)
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
float snoise(vec3 v) {
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //  x0 = x0 - 0.0 + 0.0 * C
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

  // Permutations
  i = mod289(i);
  vec4 p = permute( permute( permute(
              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  // Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix contributions from the four corners
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                dot(p2,x2), dot(p3,x3) ) );
}

// Fractal Brownian Motion
float fbm(vec3 p) {
    float f = 0.0;
    float w = 0.5;
    for (int i = 0; i < 5; i++) {
        f += w * snoise(p);
        p *= 2.0;
        w *= 0.5;
    }
    return f;
}

// Tunnel path helpers
float cosPath(vec3 p, vec3 dec){return dec.x * cos(p.z * dec.y + dec.z);}
float sinPath(vec3 p, vec3 dec){return dec.x * sin(p.z * dec.y + dec.z);}
vec2 getCylinder(vec3 p, vec2 pos, float r, vec3 c, vec3 s)
{
    return p.xy - pos - vec2(cosPath(p, c), sinPath(p, s));
}

// Procedural noise replacement for pn/fpn
float pnoise(vec3 p) {
    return fbm(p * 0.13);
}

float map(vec3 p)
{
    float pnNoise = pnoise(p) * .8;
    float path = sinPath(p ,vec3(6.2, .33, 0.));
    float bottom = p.y + pnNoise;
    float cyl = 0.0;
    vec2 vecOld = vec2(0.0);
    for (float i=0.; i<6.; i++)
    {
        float x = 1. * i;
        float y = .88 + 0.0102*i;
        float z = -0.02 -0.16*i;
        float r = 4.4 + 2.45 * i;
        vec2 vec = getCylinder(p, vec2(path, 3.7 * i), r , vec3(x,y,z), vec3(z,x,y));
        cyl = r - min(length(vec), length(vecOld));
        vecOld = vec;
    }
    cyl += pnNoise;
    cyl = min(cyl, bottom);
    return cyl;
}

vec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)
{
    vec3 rov = normalize(cv-ro);
    vec3 u =  normalize(cross(cu, rov));
    vec3 v =  normalize(cross(rov, u));
    float fov = 3.;
    vec3 rd = normalize(rov + fov*u*uv.x + fov*v*uv.y);
    return rd;
}

void main() {
    float t = u_time*2.5;
    vec2 si = u_resolution.xy;
    vec2 uv = (2.0*gl_FragCoord.xy - si) / min(si.x, si.y);
    vec3 ro = vec3(0.0), p=ro;
    ro.y = sin(t*.2)*15. + 15.;
    ro.x = sin(t*.5)*5.;
    ro.z = t*5.;
    vec3 rd = cam(uv, p, vec3(0,1,0), p + vec3(0,0,1));
    float s = 1., h = .15, td = 0., d=1., dd=0., w;
    float var = 0.03;

    // Raymarching loop
    for(float i=0.; i<100.; i++)
    {
        if(s<0.01||d>500.||td>.95) break;
        s = map(p) * (s>0.001?var:.2);
        if (s < h)
        {
            w = (1.0-td) * (h-s)*i/100.0;
            td += w;
        }
        dd += 0.012;
        td += 0.005;
        s = max(s, 0.05);
        d += s;
        p = ro+rd*d;
    }

    // Black and white fog coloring
    float fog = 1.0 - exp(-0.001*d*d);
    float col = td/dd;
    col = mix(col, fog, 0.7);

    // Vignette
    vec2 q = gl_FragCoord.xy / si;
    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );

    gl_FragColor = vec4(vec3(col), 1.0);
}

    

      </script>
  <script>
    // GLSL full screen background setup
    const canvas = document.getElementById('glsl-bg');
    const gl = canvas.getContext('webgl');
    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0, 1);
      }
    `;
    const fragShaderSource = document.getElementById('fragShader').textContent;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(vsSource, fsSource) {
      const program = gl.createProgram();
      const vShader = createShader(gl.VERTEX_SHADER, vsSource);
      const fShader = createShader(gl.FRAGMENT_SHADER, fsSource);
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(program));
      }
      return program;
    }

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const program = createProgram(vertexShaderSource, fragShaderSource);
    gl.useProgram(program);

    // Fullscreen quad
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
      1, -1,
      -1, 1,
      -1, 1,
      1, -1,
      1, 1
    ]), gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLoc);
    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const u_time = gl.getUniformLocation(program, 'u_time');
    const u_resolution = gl.getUniformLocation(program, 'u_resolution');

    function render(time) {
      gl.uniform1f(u_time, time * 0.001);
      gl.uniform2f(u_resolution, canvas.width, canvas.height);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    render(0);
  </script>
</body>
</html>
